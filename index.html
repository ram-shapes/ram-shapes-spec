<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        shortName: "ramp-shapes",
        subtitle: "RAMP shapes: declarative RDF ↔ algebraic data type mapping",
        edDraftURI: "https://ramp-shapes.github.io/ramp-shapes-spec/",
        editors: [{
          name: "Alexey Morozov",
          url: "https://github.com/AlexeyMz",
          company: "ITMO University - ISST Laboratory",
          companyURL: "http://isst.ifmo.ru/",
        }],
        authors: [{
          name: "Alexey Morozov",
          url: "https://github.com/AlexeyMz",
          company: "ITMO University - ISST Laboratory",
          companyURL: "http://isst.ifmo.ru/",
        }],
        otherLinks: [{
          key: "Version control",
          data: [{
            value: "Github Repository",
            href: "https://github.com/ramp-shapes/ramp-shapes-spec"
          }]
        }],
        localBiblio: {
          "rdfjs": {
            title: "RDF/JS: Data model specification",
            href: "http://rdf.js.org/data-model-spec/",
            status: "CG-DRAFT",
            publisher: "W3C",
          },
          "rdfjs-dataset": {
            title: "RDF/JS: Dataset specification 1.0",
            href: "https://rdf.js.org/dataset-spec/",
            status: "CG-FINAL",
            publisher: "W3C",
          },
          "XSPARQL": {
            title: "XSPARQL: Traveling between the XML and RDF worlds–and avoiding the XSLT pilgrimage",
            href: "https://link.springer.com/chapter/10.1007/978-3-540-68234-9_33",
          },
          "SPARQL.js": {
            title: "SPARQL.js – A SPARQL 1.1 parser for JavaScript",
            href: "https://github.com/RubenVerborgh/SPARQL.js",
          },
        },
      };
    </script>
    <title>RAMP shapes: declarative RDF ↔ algebraic data type mapping</title>
  </head>
  <body>
    <section id='abstract'>
      <p>
        RAMP (RDF ADT Mapping) is a type construction language, specification and an
        implementation of mapping operations between RDF graphs and structured data types.
      </p>
    </section>
    <section id='sotd'>
      <p>
        Changes to this document may be tracked at
        <a href='https://github.com/ramp-shapes/ramp-shapes.github.io'>
          https://github.com/ramp-shapes/ramp-shapes.github.io
        </a>.
      </p>
    </section>
    <section>
      <h2>External definitions</h2>
      <p>
        Commonly used types and values from ECMAScript include
          <dfn data-lt='DOMString'>string</dfn>,
          <dfn>number</dfn>,
          <dfn>boolean</dfn>,
          <dfn>null</dfn> (and <dfn data-lt="nullType">null type</dfn>),
          <dfn>undefined</dfn>,
          <dfn>unknown</dfn>.
      </p>
      <p>
        The specification references [[[WebIDL]]] spec:
        <dfn data-cite="WebIDL#Exposed">Exposed</dfn>.
      </p>
      <p>
        The specification references the following RDF types defined in [[!rdfjs]] spec:
        <dfn data-cite="rdfjs#dom-term">Term</dfn>,
        <dfn data-cite="rdfjs#dom-namednode">NamedNode</dfn>,
        <dfn data-cite="rdfjs#dom-blanknode">BlankNode</dfn>,
        <dfn data-cite="rdfjs#dom-literal">Literal</dfn>,
        <dfn data-cite="rdfjs#dom-quad">Quad</dfn>.
      </p>
      <p>
        The specification references the following types from [[!rdfjs-dataset]]:
        <dfn data-cite="rdfjs-dataset#dom-dataset">Dataset</dfn>.
      </p>
      <p>
        The specification references the following types from [[!SPARQL.js]] query AST:
        <dfn>ConstructQuery</dfn>.
      </p>
    </section>
    <section data-dfn-for="Shape" data-link-for="Shape">
      <h2><dfn>Shape</dfn> type constructors</h2>
      The set of defined types forms a type construction language with RDF-based atomic terms and ADTs (Algebraic Data Types).
      <pre class="idl">
      typedef (
        ResourceShape
        or LiteralShape
        or ObjectShape
        or UnionShape
        or OptionalShape
        or SetShape
        or ListShape
        or MapShape
      ) Shape;
      </pre>
      <section data-dfn-for="ShapeID" data-link-for="ShapeID">
        <h3><dfn>ShapeID</dfn></h3>
        <p>Shapes are referenced by <a>ShapeID</a>.</p>
        <pre class="idl">
          typedef (NamedNode or BlankNode) ShapeID;
        </pre>
      </section>
      <section data-dfn-for="ShapeBase" data-link-for="ShapeBase">
        <h3><dfn>ShapeBase</dfn></h3>
        <p>Basic shapes properties are <dfn>id</dfn> and <dfn>lenient</dfn>.</p>
        <p>
          <a>lenient</a> property sets non-strict matching mode for shape.
          See <a data-lt='RamOperations.frame()'>frame()</a> for matching mode description.
        </p>
        <pre class="idl">
          [Exposed] interface ShapeBase {
            readonly attribute ShapeID id;
            readonly attribute boolean? lenient;
          };
        </pre>
      </section>
      <section data-dfn-for="ResourceShape" data-link-for="ResourceShape">
        <h3><dfn>ResourceShape</dfn> type</h3>
        <p>
          <a>ResourceShape</a> describes an RDF resource term, which is either an IRI or a blank node:
        </p>
        <p>
          If <dfn>onlyNamed</dfn> flag is set then the shape will only match <a>NamedNode</a> but
          not <a>BlankNode</a>.
        </p>
        <pre class="idl">
        [Exposed] interface ResourceShape : ShapeBase {
          /** type == "resource" */
          readonly attribute string type;
          readonly attribute boolean? onlyNamed;
          readonly attribute (NamedNode or BlankNode)? value;
          readonly attribute Vocabulary? vocabulary;
        };
        </pre>
      </section>
      <section data-dfn-for="LiteralShape" data-link-for="LiteralShape">
        <h3><dfn>LiteralShape</dfn> type</h3>
        <p>
          <a>LiteralShape</a> describes an RDF literal term with its specified <dfn>datatype</dfn>,
          <dfn>language</dfn> (if the <a>datatype</a> is <code>rdf:langString</code>) and
          <dfn>value</dfn>:
        </p>
        <pre class="idl">
        [Exposed] interface LiteralShape : ShapeBase {
          /** type == "literal" */
          readonly attribute string type;
          readonly attribute NamedNode? datatype;
          readonly attribute string? language;
          readonly attribute Literal? value;
        };
        </pre>
      </section>
      <section data-dfn-for="ObjectShape" data-link-for="ObjectShape">
        <h3><dfn>ObjectShape</dfn> type</h3>
        <p>
          <a>ObjectShape</a> describes a product type of heterogeneous types accessible through
          named properties. Both <dfn>typeProperties</dfn> and <dfn>properties</dfn> define
          properties for a shape and the difference is when a candidate term must match given
          object shape if and only if all <a>typeProperties</a> matches, which allows to
          quickly filter a set of candidate terms by scanning only against <a>typeProperties</a>.
        </p>
        <pre class="idl">
        [Exposed] interface ObjectShape : ShapeBase {
          /** type == "object" */
          readonly attribute string type;
          getter sequence&lt;ObjectProperty&gt; typeProperties();
          getter sequence&lt;ObjectProperty&gt; properties();
        };
        </pre>
      </section>
      <section data-dfn-for="UnionShape" data-link-for="UnionShape">
        <h3><dfn>UnionShape</dfn> type</h3>
        <p>
          <a>UnionShape</a> describes a sum (coproduct) type of several types.
          The <dfn>variants</dfn> are unordered, which means matching operations
          may produce results in arbitrary order when the same candidate term
          matches multiple variant types.
        </p>
        <pre class="idl">
        [Exposed] interface UnionShape : ShapeBase {
          /** type == "union" */
          readonly attribute string type;
          getter sequence&lt;ShapeID&gt; variants();
        };
        </pre>
      </section>
      <section data-dfn-for="OptionalShape" data-link-for="OptionalShape">
        <h3><dfn>OptionalShape</dfn> type</h3>
        <p>
          <a>OptionalShape</a> describes a sum type of an empty unit type and a single type
          <dfn>itemShape</dfn>.
        </p>
        <p>
          Although this type could also be represented as
          a <a>UnionShape</a> by introducing a <code>Nothing</code> unit type like
          <a>null</a> in C-like languages, the optional type more closely resembles
          the semantics of programming languages with either no explicit <code>nothing</code>
          type or multiple such types instead (e.g. <a>null</a> and <a>undefined</a>
          in ECMAScript).
        </p>
        <pre class="idl">
        [Exposed] interface OptionalShape : ShapeBase {
          /** type == "optional" */
          readonly attribute string type;
          readonly attribute ShapeID itemShape;
          readonly attribute nullType? emptyValue;
        };
        </pre>
      </section>
      <section data-dfn-for="SetShape" data-link-for="SetShape">
        <h3><dfn>SetShape</dfn> type</h3>
        <p>
          <a>SetShape</a> describes an unordered set of a single type <dfn>itemShape</dfn>.
        </p>
        <p>
          If <dfn>minCount</dfn> or <dfn>maxCount</dfn> is specified then the shape will match
          only if matching set contains equal or more items than <a>minCount</a> and
          equal or less items than <a>maxCount</a>.
        </p>
        <pre class="idl">
        [Exposed] interface SetShape : ShapeBase {
          /** type == "set" */
          readonly attribute string type;
          readonly attribute ShapeID itemShape;
          readonly attribute number? minCount;
          readonly attribute number? maxCount;
        };
        </pre>
      </section>
      <section data-dfn-for="ListShape" data-link-for="ListShape">
        <h3><dfn>ListShape</dfn> type</h3>
        <p>
          <a>ListShape</a> describes an ordered set (<a data-cite="WebIDL#idl-sequence">sequence</a>)
          of a single type <dfn>itemShape</dfn>.
        </p>
        <p>
          By default a <a>ListShape</a> represents RDF list structures, however it is possible to
          override <dfn>headPath</dfn>, or <dfn>tailPath</dfn> property paths and <dfn>nil</dfn> term
          to describe other kinds of ordered structures.
        </p>
        <pre class="idl">
        [Exposed] interface ListShape : ShapeBase {
          /** type == "list" */
          readonly attribute string type;
          readonly attribute ShapeID itemShape;
          readonly attribute PropertyPath? headPath;
          readonly attribute PropertyPath? tailPath;
          readonly attribute NamedNode? nil;
        };
        </pre>
      </section>
      <section data-dfn-for="MapShape" data-link-for="MapShape">
        <h3><dfn>MapShape</dfn> type</h3>
        <p>
          <a>MapShape</a> describes an unordered set (<a data-cite="WebIDL#idl-record">record</a>) of items
          with type <dfn>itemShape</dfn> indexed by a <dfn>key</dfn> and (optionally) <dfn>value</dfn>.
        </p>
        <p>
          Any nested shape value, datatype or language may be chosen as the key. When <a>MapShape</a> includes
          a nested map value with the same <a>key</a>, the key always refers to the innermost map shape.
          A <a>key</a> shape may be limited to non-composite types depending on the implementation.
        </p>
        <pre class="idl">
        [Exposed] interface MapShape : ShapeBase {
          /** type == "map" */
          readonly attribute string type;
          readonly attribute ShapeReference key;
          readonly attribute ShapeReference? value;
          readonly attribute ShapeID itemShape;
        };
        </pre>
      </section>
    </section>
    <section>
      <h2>Utility interfaces</h2>
      <section data-dfn-for="Vocabulary" data-link-for="Vocabulary">
        <h3><dfn>Vocabulary</dfn> interface</h3>
        <p>
          <a>Vocabulary</a> describes a mapping between <a>NamedNode</a> terms and <a>string</a> keys.
          The mapping allows to refer to RDF resources by short names in
          by matching against <dfn>terms</dfn> dictionary.
        </p>
        <pre class="idl">
        [Exposed] interface Vocabulary {
          getter record&lt;DOMString, NamedNode&gt; terms();
        };
        </pre>
      </section>
      <section data-dfn-for="ObjectProperty" data-link-for="ObjectProperty">
        <h3><dfn>ObjectProperty</dfn> interface</h3>
        <p>
          <a>ObjectProperty</a> describes a named property in a record type.
          It is specified by its <dfn>name</dfn> string, <dfn data-lt="path">property path</dfn> and
          <dfn data-lt="valueShape">value shape</dfn>. A property with zero-length path allows to embed
          a different representation of the same subject, e.g. the subject IRI itself.
        </p>
        <p>
          If <dfn>transient</dfn> flag is set then in <a>RamOperations.frame()</a> the framing result
          will be discarded; in <a>RamOperations.flatten()</a> the value for <a>valueShape</a> will be
          synthesized or an error will be thrown if it is not possible.
        </p>
        <pre class="idl">
        [Exposed] interface ObjectProperty {
          readonly attribute string name;
          readonly attribute PropertyPath path;
          readonly attribute ShapeID valueShape;
          readonly attribute boolean? transient;
        };
        </pre>
      </section>
      <section data-dfn-for="PropertyPath" data-link-for="PropertyPath">
        <h3><dfn>PropertyPath</dfn> interface</h3>
        <p>
          <a>PropertyPath</a> describes a property path in RDF graph.
        </p>
        <pre class="idl">
        typedef (
          PredicatePath or
          SequencePath or
          InversePath or
          AlternativePath or
          ZeroOrMorePath or
          ZeroOrOnePath or
          OneOrMorePath
        ) PropertyPath;
        </pre>
        <section data-dfn-for="PredicatePath" data-link-for="PredicatePath">
          <h3><dfn>PredicatePath</dfn> path kind</h3>
          <p>
            <a>PredicatePath</a> describes a property path represented by a single <a>NamedNode</a>
            predicate.
          </p>
          <pre class="idl">
          [Exposed] interface PredicatePath {
            /** type == "predicate" */
            readonly attribute string type;
            readonly attribute NamedNode predicate;
          };
          </pre>
        </section>
        <section data-dfn-for="SequencePath" data-link-for="SequencePath">
          <h3><dfn>SequencePath</dfn> path kind</h3>
          <p>
            <a>SequencePath</a> describes a property path which is an ordered sequence
            of <a>PropertyPath</a> elements.
          </p>
          <pre class="idl">
          [Exposed] interface SequencePath {
            /** type == "sequence" */
            readonly attribute string type;
            getter sequence&lt;PropertyPath&gt; sequence_();
          };
          </pre>
        </section>
        <section data-dfn-for="InversePath" data-link-for="InversePath">
          <h3><dfn>InversePath</dfn> path kind</h3>
          <p>
            <a>InversePath</a> describes a property path which is an inverse of
            another <a>PropertyPath</a>.
          </p>
          <pre class="idl">
          [Exposed] interface InversePath {
            /** type == "inverse" */
            readonly attribute string type;
            readonly attribute PropertyPath inverse;
          };
          </pre>
        </section>
        <section data-dfn-for="AlternativePath" data-link-for="AlternativePath">
          <h3><dfn>AlternativePath</dfn> path kind</h3>
          <p>
            <a>AlternativePath</a> describes a property path which is a union of
            alternative <a>PropertyPath</a> elements.
          </p>
          <pre class="idl">
          [Exposed] interface AlternativePath {
            /** type == "alternative" */
            readonly attribute string type;
            getter sequence&lt;PropertyPath&gt; alternatives();
          };
          </pre>
        </section>
        <section data-dfn-for="ZeroOrMorePath" data-link-for="ZeroOrMorePath">
          <h3><dfn>ZeroOrMorePath</dfn> path kind</h3>
          <p>
            <a>ZeroOrMorePath</a> describes a property path which is a zero or more
            repetitions of another <a>PropertyPath</a>.
          </p>
          <pre class="idl">
          [Exposed] interface ZeroOrMorePath {
            /** type == "zeroOrMore" */
            readonly attribute string type;
            readonly attribute PropertyPath zeroOrMore;
          };
          </pre>
        </section>
        <section data-dfn-for="ZeroOrOnePath" data-link-for="ZeroOrOnePath">
          <h3><dfn>ZeroOrOnePath</dfn> path kind</h3>
          <p>
            <a>ZeroOrOnePath</a> describes a property path which is a zero or one
            repetition of another <a>PropertyPath</a>.
          </p>
          <pre class="idl">
          [Exposed] interface ZeroOrOnePath {
            /** type == "zeroOrOne" */
            readonly attribute string type;
            readonly attribute PropertyPath zeroOrOne;
          };
          </pre>
        </section>
        <section data-dfn-for="OneOrMorePath" data-link-for="OneOrMorePath">
          <h3><dfn>OneOrMorePath</dfn> path kind</h3>
          <p>
            <a>OneOrMorePath</a> describes a property path which is a one or more
            repetitions of another <a>PropertyPath</a>.
          </p>
          <pre class="idl">
          [Exposed] interface OneOrMorePath {
            /** type == "oneOrMore" */
            readonly attribute string type;
            readonly attribute PropertyPath oneOrMore;
          };
          </pre>
        </section>
      </section>
      <section data-dfn-for="ShapeReference" data-link-for="ShapeReference">
        <h3><dfn>ShapeReference</dfn> interface</h3>
        <p>
          <a>ShapeReference</a> describes a reference to a candidate term matched by
          <dfn>target</dfn> <a>Shape</a>.
          A reference may target whole <a>Term</a> value or a specific <dfn>part</dfn> such as
          language or datatype of a <a>Literal</a>.
        </p>
        <pre class="idl">
        [Exposed] interface ShapeReference {
          readonly attribute ShapeID target;
          /** part in ("value" or "datatype" or "language") */
          readonly attribute string? part;
        };
        </pre>
      </section>
      <section data-dfn-for="ValueMapper" data-link-for="ValueMapper">
        <h3><dfn>ValueMapper</dfn> interface</h3>
        <p>
          <a>ValueMapper</a> describes two-way mapping between atomic RDF terms and "leaf"
          data structures such as primitive types (<code>number</code>, <code>string</code>,
          <code>DataTime</code>, etc).
        </p>
        <pre class="idl">
        [Exposed] interface ValueMapper {
          unknown fromRdf(unknown value, Shape shape);
          unknown toRdf(unknown value, Shape shape);
        };
        </pre>
      </section>
    </section>
    <section>
      <h2>Workflow operations</h2>
      The specification of operations on the described data types includes the following methods:
      <pre class="idl">
      [Exposed] interface RamOperations {
        sequence&lt;unknown&gt; frame(FrameParams params);
        sequence&lt;Quad&gt; flatten(FlattenParams params);
        ConstructQuery generateQuery(GenerateQueryParams params);
        /* TODO: ValidationReport validate(ValidateParams params); */
      };
      </pre>
      <section data-dfn-for="FrameParams" data-link-for="FrameParams">
        <h3><dfn data-lt="RamOperations.frame()">frame()</dfn> operation</h3>
        <p>
          <a data-lt='RamOperations.frame()'>frame()</a> matches RDF <dfn>dataset</dfn> into
          <dfn>shapes</dfn> from enty point <dfn>rootShape</dfn> and forms data structures
          corresponding to these shapes.
          This operation is usually referred to as <em>RDF lowering</em> (see [[!!XSPARQL]]).
        </p>
        <pre class="idl">
        dictionary FrameParams {
          ShapeID rootShape;
          sequence&lt;Shape&gt; shapes;
          Dataset dataset;
          ValueMapper? mapper;
        };
        </pre>
        <p>
          Returns: <code class="idl">sequence&lt;unknown&gt;</code> &mdash; all found matches
          where each one is an instance of <a>rootShape</a>.
        </p>
        <section>
          <h4>Frame matching mode</h4>
          <p>
            The matching for each shape may operate in either <code>strict</code> or
            <code>lenient</code> mode. The mode initializes as <code>lenient</code> and propagates
            downwards from <a>rootShape</a>, changing at these points:
            <ul>
              <li>
                If <a>ObjectShape</a> has <a data-lt="ObjectShape.typeProperties">typeProperties</a>
                then the mode switches to <code>strict</code> when matching other
                <a data-lt="ObjectShape.properties">properties</a>.
              </li>
              <li>
                If a shape set <a data-lt="ShapeBase.lenient">lenient</a> property to
                <code class="idl">true</code> then the mode switches to <code>lenient</code>
                starting from that shape.
              </li>
            </ul>
            In <code>strict</code> mode a non-matching candidate term will be considered an error
            which is reported to the caller. In <code>lenient</code> mode non-matching candidate
            terms are ignored and produce no matches for given shape.
          </p>
        </section>
      </section>
      <section data-dfn-for="FlattenParams" data-link-for="FlattenParams">
        <h3><dfn data-lt="RamOperations.flatten()">flatten()</dfn> operation</h3>
        <p>
          <a data-lt='RamOperations.flatten()'>flatten()</a> generates
          <a data-lt="Dataset">RDF dataset</a> from <dfn>value</dfn> which must be an instance
          of <dfn>rootShape</dfn> entry point and contain valus described by <dfn>shapes</dfn>.
          This operation is usually referred to as <em>RDF lifting</em> (see [[XSPARQL]]).
        </p>
        <pre class="idl">
        dictionary FlattenParams {
          ShapeID rootShape;
          sequence&lt;Shape&gt; shapes;
          unknown value;
          ValueMapper? mapper;
        };
        </pre>
        <p>
          Returns: <code class="idl">sequence&lt;Quad&gt;</code> &mdash; generated RDF dataset
          content which may contain duplicate quads.
        </p>
      </section>
      <section data-dfn-for="GenerateQueryParams" data-link-for="GenerateQueryParams">
        <h3><dfn data-lt="RamOperations.generateQuery()">generateQuery()</dfn> operation</h3>
        <p>
          <a data-lt='RamOperations.generateQuery()'>generateQuery()</a> generates SPARQL
          <a data-cite='sparql11-query#construct'>CONSTRUCT query</a> to fetch a subset
          of RDF graph data necessary to match given <dfn>shapes</dfn> starting from entry
          point <dfn>rootShape</dfn>.
        </p>
        <pre class="idl">
        dictionary GenerateQueryParams {
          ShapeID rootShape;
          sequence&lt;Shape&gt; shapes;
          NamedNode? base;
          record&lt;DOMString, string&gt;? prefixes;
        };
        </pre>
        <p>
          Returns: <code class="idl">ConstructQuery</code> &mdash; generated query in [[SPARQL.js]]
          query AST representation with specified <dfn>base</dfn> and <dfn>prefixes</dfn> for
          <a data-cite='sparql11-query#syntaxTerms'>graph terms</a>.
        </p>
      </section>
    </section>
  </body>
</html>
